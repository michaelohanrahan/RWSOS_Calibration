# Workflow for the calibration of the wflow model
# This workflow is used to calibrate the wflow model using the data built in the databuilder subworkflow

#@michaelohanrahan
#@jingdeng

import json
import shutil
import os
import platform
from pathlib import Path
from snakemake.utils import Paramspace
import geopandas as gpd
from src.calib.create_set_params import create_set
import glob

#=========================================================
## Directories and paths
if platform.system() == "Windows":
    DRIVE = "p:"
else:
    DRIVE = "/p"

# if "TEST" in config["calib_recipe"]:
#     print("\033[91m" + "WARNING: 'TEST' found in the calib_recipe filepath!" + "\033[0m")

## Some preparatory actions
# Ensure the model directory is there
config: 'config/calib.yml'

#default directories
base_dir = Path(DRIVE, config["base_dir"])                         # p: or /p/ ... / RWSOS_Calibration / basin
basin = config["basin"]                                     # meuse
#working directory
os.chdir(Path(base_dir, basin))

# print(f"\033[94m{'*'*20}\n{'-'*10} calibrating: {basin}\n{'*'*20}\033[0m")
source_dir = Path(base_dir, basin, config["source_dir"])    # data/1-external
inter_dir = Path(base_dir, basin, config["inter_dir"])      # data/2-intermediate
input_dir = Path(base_dir, basin, config["input_dir"])      # data/3-input
out_dir = Path(base_dir, basin, config["output_dir"])       # data/4-output
vis_dir = Path(base_dir, basin, config["vis_dir"])          # data/5-visualisation

for dir in [source_dir, inter_dir, out_dir, vis_dir, input_dir]:
    os.makedirs(dir, exist_ok=True)

gauges = config["gauges"]

#find last level from the final level directory
levels = glob.glob(str(Path(inter_dir,'calib_data', "level*")))
last_level = int(levels[-1].split("level")[-1])

#define elements from the staticgeoms
elements = list(gpd.read_file(Path(input_dir,"staticgeoms", f'subcatch_{config["gauges"]}.geojson'))["value"].values)

#paramspace
lnames, methods, df = create_set(config["calib_recipe"])
paramspace = Paramspace(df)

#staticmaps
staticmaps = Path(input_dir, "staticmaps", "staticmaps.nc")

#subcatch
subcatch = Path(input_dir, "staticgeoms", f'subcatch_{config["gauges"]}.geojson')

#cfg template
cfg_template = Path(input_dir, "wflow_sbm.toml")

#calib_dir
calib_dir = Path(inter_dir, "calib_data")

#graph
graph = json.load(open(Path(inter_dir, f'{config["gauges"]}_levels_graph.json')))

############################
# DOING the snakey!
############################
# Define the main rule all that expects all the visualization files to have been created for successfull completion
# rule all:
# Define the main rule all that expects all the visualization files to have been created for successful completion
rule all:
    input: expand(Path(vis_dir, "hydro_gauge", "hydro_{gauge}.png"), gauge=elements)
    default_target: True

'''
This rule isnt waiting for the output of a previous rule, so it is run first and only once. 
'''

rule initial_instates: #level 0
    input:
        toml = cfg_template, #the input template
        soilthicknesses= LIST
    output:
        expand(Path(input_dir, "instate", "instate_level0_ST{thicnkess}"), thicnkess=soilthicknesses)
    script:
        """
        julia modify tomls and run instates for desired thicknesses
        """


'''
config: This rule modifies a blueprint configuration file for a specific time period and forcing path. 
        It takes the blueprint configuration file, start time, end time, time step, and forcing path as parameters. 
        The output is a set of modified configuration files.
#TODO: in each config that accesses a certain level && soilthickness the instate reference should match
'''

rule config:
    # input: lambda wildcards: expand(Path(calib_dir, "{dep}", "done.txt").as_posix(), dep=graph[wildcards.item]["deps"]) if graph[wildcards.item]["deps"] else []
    params: 
        cfg_template = cfg_template,
        starttime = config["starttime"],
        endtime = config["endtime"],
        timestep = config["timestep"],
        forcing_path = Path(input_dir, config["source_forcing_data"])
    output: expand(Path(calib_dir, "level"+"{item}", "{params}", config["wflow_cfg_name"]), item=f"{{item}}", params=paramspace.wildcard_pattern)
    script:
        """src/calib/set_config.py"""

'''
@JING ...
create_params:  This rule creates parameter sets for the Wflow model. 
                It takes a configuration file, a dataset of static maps, a parameter space instance, 
                a list of parameter names, a list of parameter methods, a level, a graph, and a sub-catchment as parameters. 
                The output is a set of static map files.
#TODO: Make sure the co-scaling logic is here.... 
'''

rule create_params:
    input: Path(calib_dir, "level"+"{item}", paramspace.wildcard_pattern, config["wflow_cfg_name"])
    params:
        dataset = staticmaps,
        params = paramspace.instance,
        params_lname = lnames,
        params_method = methods,
        level = "level"+"{item}",
        graph = graph,
        sub_catch = subcatch
    output: 
        staticmaps = Path(calib_dir, "level"+"{item}", paramspace.wildcard_pattern, "staticmaps.nc")
    script: 
        """src/calib/set_calib_params.py"""
'''
NEWRULE - where to place this? 
#TODO: make sure that the new ST is only applied at the current level?
'''
rule auto_instate_per_level:
    input: Path(calib_dir, "level"+"{item}", "done.txt") 
    output: Path(instates)
    script: 
        """
        SOme julia 
        """

'''
wflow: This rule runs the hydrological model. It takes a configuration file and a grid (staticmap) file as input.
#TODO: is it the Wflow rule that should have the instates as an expected input??? 
#TODO: Only using the CAL time split. 
'''

rule wflow:
    input: 
        cfg = Path(calib_dir, "level"+"{item}", paramspace.wildcard_pattern, config["wflow_cfg_name"]),
        staticmaps = Path(calib_dir, "level"+"{item}", paramspace.wildcard_pattern, "staticmaps.nc")
    output: Path(calib_dir, "level"+"{item}", paramspace.wildcard_pattern, "run_default", "output_scalar.nc")
    shell: 
        f"""julia --project="{config['wflow_project_dir']}" -t {config['wflow_threads']} -e "using Wflow; Wflow.run()" {{input.cfg}}"""

'''
@JING 25.07
Evaluate: This rule evaluates the performance of the model by comparing the model output with observed data and outputs the best parameters and performance metrics.
Output:  an unstacked performance.nc file with metrics and weights for each parameter set, and a best_params.csv file with the best parameter set.
        out csv with the best parameter set for each gauge 
        
#TODO: discuss if we want to have a multiple param selection.. 
    - can sample within distance tolerance of weighted euclidian sample
#TODO: add parameter to fn to sample from the 10 closest to minima
'''

rule evaluate:
    input: expand(Path(calib_dir, "level"+"{item}", "{params}", "run_default", "output_scalar.nc"), item=f"{{item}}", params=paramspace.instance_patterns)
    params: 
        observed_data = Path(source_dir, config["observed_data"]),
        level = "{item}",
        graph = graph,
        params = df.to_dict(orient="records"), 
        starttime = config["eval_starttime"],
        endtime = config["eval_endtime"],
        metrics = config["metrics"], #["kge", "nselog_mm7q_res", "peak_res"] #TODO: figure out how to split out the dictionary approach of peak res to get the right values
        weights = config["weights"] #
    output: 
        best_params = Path(calib_dir, "level"+"{item}", "best_params.csv"),
        performance = Path(calib_dir, "level"+"{item}", "performance.nc")
    script: 
        """src/calib/evaluate_params.py"""         # TODO: modify this script

'''
SUMMARY
'''

rule set_params:
    input: 
        best_params = Path(calib_dir, "level"+"{item}", "best_params.csv")
    params:
        staticmaps = staticmaps,
        sub_catch = subcatch,
        params_lname = lnames,
        params_method = methods
    output: 
        done = Path(calib_dir, "level"+"{item}", "done.txt")
    script:
        """src/calib/set_eval_params.py"""

'''
Preparing the final stage: This rule prepares the final stage of the calibration process.
'''

rule prep_final_stage:
    input: 
        done = Path(calib_dir, "level"+f'{last_level}', "done.txt"),
        performance = expand(Path(calib_dir, "{level}", "performance.nc"), level=list(graph.keys()))
    params:
        cfg_template = cfg_template,
        cfg_args = [config["starttime"], config["endtime"], config["timestep"], Path(source_dir, config["source_forcing_data"])],
        staticmaps = staticmaps
    output: 
        cfg = Path(input_dir, config["wflow_cfg_name"]),
        performance = Path(out_dir, "performance.nc"),
        staticmaps = Path(input_dir, "staticmaps.nc")
    script:
        """src/calib/prep_final_stage.py"""

rule run_final_model:
    input:
        cfg = Path(input_dir, config["wflow_cfg_name"]),
        staticmaps = Path(input_dir, "staticmaps.nc")
    output: Path(out_dir, "run_default", "output_scalar.nc")
    shell:
        f"""julia --project="{config['wflow_project_dir']}" -t {config['model_threads']} -e "using Wflow; Wflow.run()" {{input.cfg}}"""

rule visualize:
    input: 
        scalar = Path(out_dir, "run_default", "output_scalar.nc"),
        performance = Path(out_dir, "performance.nc")
    params:
        observed_data = config["observed_data"],
        gauges = elements,
        starttime = config["eval_starttime"],
        endtime = config["eval_endtime"],
        period_startdate = config["hydro_period_startdate"],
        period_length = config["hydro_period_length"],
        period_unit = config["hydro_period_unit"],
        output_dir = Path(vis_dir, "figures")
    output:
        figures = expand(Path(vis_dir, "hydro_gauge", "hydro_{gauge}.png"), gauge=elements)
    script:
        """src/post/plot_final_model.py"""